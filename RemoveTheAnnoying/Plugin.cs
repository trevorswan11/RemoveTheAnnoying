using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using BepInEx;
using BepInEx.Logging;
using HarmonyLib;

namespace RemoveTheAnnoying
{
    [BepInPlugin(modGUID, modName, modVersion)]
    public class RemoveAnnoyingBase : BaseUnityPlugin
    {
        private const string modGUID = "Kyoshi.RemoveAnnoyingStuff";
        private const string modName = "Remove Annoying Mechanics";
        private const string modVersion = "1.0.0";

        private readonly Harmony harmony = new Harmony(modGUID);

        private static RemoveAnnoyingBase Instance;

        public static ManualLogSource mls;

        void Awake()
        {
            if (Instance == null)
            {
                Instance = this;
            }

            mls = BepInEx.Logging.Logger.CreateLogSource(modGUID);

            mls.LogInfo("The game is now more playable!");

            harmony.PatchAll(typeof(RemoveAnnoyingBase));
        }
    }

    /// <summary>
    /// The different interior types for the current version.
    /// </summary>
    public enum InteriorType
    {
        FACTORY,
        MANOR,
        MINESHAFT
    }
}

namespace RemoveTheAnnoying.Patches
{
    [HarmonyPatch(typeof(StartOfRound), "NewRandomSeed")]
    public class NewRandomSeedPatch
    {
        private static readonly ManualLogSource Logger = RemoveAnnoyingBase.mls;

        private static void Regenerate(StartOfRound startOfRound)
        {
            int randomSeed = startOfRound.randomMapSeed;
            RoundManager manager = RoundManager.Instance;
            InteriorType? type = DetermineType(randomSeed, manager);

            // Check if the interior type is valid
            if (!type.HasValue)
            {
                return;
            }
            type = type.Value;

            // Check if the map is ok
            if (type.GetValueOrDefault() != InteriorType.MINESHAFT)
            {
                Logger.LogInfo("Mineshaft is not generated by current seed.");
                return;
            }

            // Otherwise the map must be a mineshaft
            Logger.LogInfo("Mineshaft seed identified, trying to regenerate...");
            manager.hasInitializedLevelRandomSeed = false;
            manager.InitializeRandomNumberGenerators();

            // Limit to 1000 total generation attempts
            for (int i = 0; i < 1000; i++)
            {
                randomSeed = NewSeed();
                type = DetermineType((int)randomSeed, manager);
                Logger.LogInfo($"Attempt {i} - Seed: {randomSeed} Interior: {type}");

                // Check for valid interior type
                if (!type.HasValue)
                {
                    Logger.LogWarning("Detected unknown interior.");
                    return;
                }

                // Check for mineshaft
                if (new InteriorType?(type.Value).GetValueOrDefault() != InteriorType.MINESHAFT)
                {
                    startOfRound.randomMapSeed = randomSeed;
                    Logger.LogInfo($"Generated new map seed: {randomSeed} after {i + 1} attempst.");
                    return;
                }
            }
            Logger.LogWarning("Regeneration failed after 1000 attempts");
        }

        /// <summary>
        /// Uses a given seed and round manager to determine the interior type.
        /// </summary>
        /// <param name="seed">The current map seed as an int.</param>
        /// <param name="manager">The custom current RoundManager object.</param>
        /// <returns>The type of the map given the seed, or null if not found.</returns>
        private static InteriorType? DetermineType(int seed, RoundManager manager)
        {
            Random rnd = new Random(seed);
            List<int> lst = manager.currentLevel.dungeonFlowTypes.Select((IntWithRarity flow) => flow.rarity).ToList();
            RemoveAnnoyingBase.mls.LogDebug("List: " + string.Join(", ", lst));
            int weight = manager.GetRandomWeightedIndex(lst.ToArray(), rnd);
            RemoveAnnoyingBase.mls.LogDebug($"Weight: {weight}");
            int id = manager.currentLevel.dungeonFlowTypes[weight].id;

            // Check the enum for the id
            if (Enum.IsDefined(typeof(InteriorType), id))
            { 
                return (InteriorType)id;
            }
            return null;
        }

        /// <summary>
        /// Generates a new random seed.
        /// </summary>
        /// <returns>An int value between 1 and 100 million</returns>
        private static int NewSeed() => new Random().Next(1, 100_000_000);
    }

     
}
